# Debugger

## Gnu DeBugger

GDB ย่อมาจาก "Gnu DeBugger" เป็นแพ็คเกจดีบั๊กsource-levelที่สามารถดูสิ่งที่เกิดขึ้นภายในโปรแกรม สามารถที่จะไล่ดูโค้ด, ตั้งbreakpoints, ตรวจสอบ/เปลี่ยนแปลงตัวแปร และอื่นๆ, มีหลายgraphical front ends สำหรับ GDB ที่แปลงคำสั่ง GUI เป็นคำสั่งข้อความ, และคล้ายกับเครื่องมือ Linux ส่วนใหญ่, GDB ก็ใช้ระบบ command line, ซึ่งทำให้มีการใช้งานที่ค่อนข้างยากเช่นกัน

GDB สามารถตั้งค่าให้ทำงานบนเครื่องหลัก ขณะที่ debug โค้ดบนเครื่องอื่นได้ และทั้งสามารถเชื่อมต่อกันผ่านพอร์ตซีเรียลหรือเน็ตเวิร์ค หรือ in-circuit emulator (ICE) ได้ 

การจะ debug โค้ดนั้น โค้ดจะต้องถูกคอมไพล์พร้อมข้อมูลการ debug ส่วนใหญ่นั้นสามารถทำได้โดยการเพิ่มตัวดัชนี "-g" เข้าไปในลิสต์ของคอมไพเลอร์เมื่อทำการคอมไพล์

แต่การ debug แอปพลิเคชันพร้อมกันบน commodity cluster  ทำให้เกิดความซับซ้อนหลายอย่าง โดยวิธีที่ง่ายและตรงไปตรงมาในการ debug แอปพลิเคชันพร้อมกันบน commodity cluster คือการใช้ serial debugger สำหรับแต่ละกระบวนการ

## GDB Tutorial

Gdb คือ debugger สำหรับภาษา C และC++ ที่ทำให้สามารถรันโปรแกรมได้จนถึงจุดหนึ่ง ทำการหยุดรันแล้วปริ้นค่า ตัวแปรที่กำหนด, หรือทำคำสั่งไปทีละบรรทัด และปริ้นค่าของแต่ละตัวแปรหลังจากที่ทำคำสั่งบรรทัดนั้น โดยการใช้ command line interface.

## Compiling

การจะ debug โปรแกรมด้วยGDBนั้น, โปรแกรมจะต้องถูกคอมไพล์ด้วยตัวดัชนี “-g” ถ้าหากโปรแกรมอยู่ใน source file ชื่อ *memsim.c* และอยากใส่โค้ดที่ทำงานได้บนไฟล์ *memsim*, จะจำเป็นต้องcompile ด้วยคำสั่งต่อไปนี้:

`gcc -g -o memsim memsim.c`

## Invoking and Quitting GDB

สามารถพิมพ์ *gdb* ลงบน unix prompt เพื่อเริ่ม GDB ได้. โดยGDB จะให้ prompt *(gdb)* โดยจะสามารถรันโปรแกรม, ดูตัวแปร, ใช้งานคำสั่ง, หรือเริ่ม GDB และให้ชื่อโปรแกรมที่ต้องการจะ debug ด้วย

`gdb executable`

หรือจะพิมพ์ *quit* หรือ *q* ที่ *(gdb)* prompt เพื่อออกจากโปรแกรมก็ได้

## Commands

**help**

-GDB จะมีเอกสารออนไลน์อยู่. เพียงพิมพ์ *help* ก็จะแสดงหัวข้อต่างๆ จากนั้นพิมพ์ *help topic* เพื่อรับข้อมูลเกี่ยวกับหัวข้อนั้นๆ หรือพิมพ์*help command* เพื่อรับข้อมูลเกี่ยวกับคำสั่งต่างๆ

**file**

-*file executable* บ่งบอกโปรแกรมที่คุณต้องการจะ debug.

**run**

-*run* จะเริ่มการทำงานของโปรแกรมด้วย GDB โดยจะเป็นโปรแกรมที่เคยเลือกไว้ผ่านคำสั่ง *file*, หรือบน Unix command line ตอนที่เริ่มการทำงานของGDB, คุณสามารถให้ command line arguments ให้กับโปรแกรมของคุณบน GDB command เหมือนกับที่ทำบน Unix command line, แต่จะเป็นการพิมพ์ *run* แทนชื่อโปรแกรม:

`run 2048 24 4`

หรือใช้ทำการเปลี่ยนเส้นทางของ input/output ด้วย: *run > outfile.txt*

**break**

-breakpoint คือตำแหน่งบนโปรแกรมที่คุณต้องการให้หยุดการทำงานชั่วคราวเพื่อเช็คค่าของตัวแปร, หาจุดที่เป็นปัญหาของโปรแกรม, และอื่นๆ โดยกำหนดจุด breakpoint ด้วยคำสั่ง *break* 

*break function* จะกำหนด breakpoint ที่จุดเริ่มต้นของ *function* ถ้าหากโค้ดอยู่ในหลายๆไฟล์, อาจจะต้องกำหนดชื่อไฟล์ด้วย *filename:function*

*break linenumber* หรือ *break filename:linenumber* จะกำหนด breakpoint ที่บรรทัดที่กำหนดใน source file โดยจะหยุดการทำงานก่อนที่บรรทัดนั้นจะทำงาน

**delete**

-*delete* จะลบ breakpoints ทั้งหมดที่ได้กำหนดไว้

*delete number* จะลบ breakpoints ตามค่า *number* ที่กำหนด โดยสามารถดูค่าของ breakpoint ได้โดยใช้ *info breakpoints*

**clear**

-*clear function* จะลบ breakpoints ที่ได้กำหนดไว้ในfunctionนั้นๆ และใช้ *linenumber, filename:function, และ filename:linenumber*  คล้ายๆกันกับคำสั่ง *break*

**continue**

-*continue* จะสั่งให้โปรแกรมทำงานต่ออีกครั้งหลังจากที่หยุดบน breakpoint.

**step**

-*step* จะทำการทำงานคำสั่งบนบรรทัดปัจจุบัน, แล้วหยุดทำงานอีกครั้งก่อนทำงานบรรทัดถัดไป 

**next**

-*next* จะทำงานคล้ายๆกับ *step*, แต่ถ้าบรรทัดที่กำลังจะทำงานนั้นเป็นคำสั่งเรียกใช้ฟังก์ชัน จะทำการทำงานทั้งฟังก์ชันที่เรียกนั้นก่อนที่จะหยุดการทำงานอีกครั้ง, ขณะที่ *step* จะหยุดการทำงานที่บรรทัดแรกของฟังก์ชันที่ถูกเรียกมา

**until**

-*until* จะเหมือนกับ *next*, แต่ว่าหากอยู่ที่ท้ายloop *until* จะทำงานต่อไปจนกว่าจะออกจากloop ขณะที่ *next* จะพากลับไปยังจุดเริ่มของ loop จึงเหมาะสำหรับดูผลที่จะเกิดขึ้นหลังจากการloop แต่ไม่ต้องการจะข้ามทุกการทำซ้ำ

**list**

-*list linenumber* จะปริ้นบรรทัดบางส่วนจาก source code ตรงที่ *linenumber* หากมีการกำหนด argument *function* จะทำให้มีการปริ้นบรรทัดตั้งแต่ต้นฟังก์ชั่น การใช้ *list* โดยไม่มี arguments จะทำการปริ้นบรรทัดถัดไปจากบรรทัดล่าสุดที่ปริ้นด้วยคำสั่ง *list* 

**print**

-*print expression* จะทำการปริ้นค่าของ expression ที่สามารถเป็นได้ตั้งแต่ชื่อตัวแปร, ไปจนถึงค่าใน array ตามจำนวนค่าที่กำหนดโดยเรียกว่า *list* ด้วยคำสั่ง

`print list[0]@amount`

