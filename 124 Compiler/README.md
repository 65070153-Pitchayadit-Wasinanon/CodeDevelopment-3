# Compiler <br>
Compiler คือโปรแกรมคอมพิวเตอร์ที่แปลงภาษาโปรแกรมระดับสูง (high-level programming language) ไปเป็นภาษาเครื่อง (machine language) ภาษาเครื่องเป็นภาษาที่ CPU ของคอมพิวเตอร์เข้าใจและใช้งานได้โดยตรง Compiler ทำหน้าที่แปลโค้ดที่เขียนโดยมนุษย์ให้เป็นชุดคำสั่งที่ CPU เข้าใจได้
## ขั้นตอนการทำงานของ Compiler
![How does the compiler work](https://media.geeksforgeeks.org/wp-content/uploads/20200524115722/Capture3311.png)<br>
[Lexical Analysis](#Lexical-Analysis)<br>
[Syntax Analysis](#Syntax-Analysis)<br>
[Semantic Analysis](#Semantic-Analysis)<br>
[Intermediate Code Generation](#IGC)<br>

## Lexical Analysis (การวิเคราะห์ตัวอักษร)
<a name="Lexical-Analysis"></a>
เป็นขั้นตอนแรกในการดำเนินการคอมไพล์โปรแกรมที่เป็นภาษามนุษย์ไปเป็นภาษาเครื่อง ซึ่งมักจะเป็นขั้นตอนที่สำคัญในกระบวนการคอมไพล์โดยทั่วไป เป้าหมายหลักของ lexical analysis คือการแยกแยะและการจับคู่ส่วนประกอบของโค้ดโปรแกรมให้อยู่ในรูปแบบที่สามารถทำการวิเคราะห์และแปลงไปเป็นโค้ดที่เป็นภาษาเครื่องได้ ซึ่งมันมุ่งเน้นไปที่การตรวจสอบความถูกต้องของโค้ดในระดับของตัวอักษรหรือ Token ซึ่งเป็นชุดของตัวอักษรที่มีความหมายรวมกันเป็นหน่วยๆ ซึ่งมักจะรวมถึงคำสั่ง เครื่องหมาย และค่าคงที่ เป็นต้น <br>
![Lexical Analysis](https://binaryterms.com/wp-content/uploads/2021/11/Lexical-Analysis-in-Compiler.jpg)<br>
### Lexical Analyser ทำงานยังไง
<a name="Lexical-Analyser"></a>
* Input preprocessing:  ขั้นตอนนี้จะทำความสะอาดข้อความอินพุตเพื่อเตรียมสำหรับการวิเคราะห์ทางไวยากรณ์ ซึ่งรวมถึงการลบส่วนประกอบที่ไม่จำเป็นออกไป เช่น คำอธิบาย ช่องว่าง ตัวอักษรพิเศษ เป็นต้น<br>
* Tokenization: ขั้นตอนนี้จะแบ่งข้อความอินพุตออกเป็นหน่วยข้อมูลเล็กๆ ที่เรียกว่า "โทเค็น" โดยมักจะใช้รูปแบบหรือการแสดงออกแบบปกติ (regular expressions) ในการจับคู่ตัวอักษรในข้อความอินพุตกับรูปแบบต่างๆ ของโทเค็น
* Token classification: ขั้นตอนนี้จะกำหนดประเภทของแต่ละโทเค็น ตัวอย่างเช่น ในภาษาโปรแกรม ตัวแบ่งประเภทโทเค็น (lexer) อาจจำแนกคีย์เวิร์ด ตัวระบุ ตัวดำเนินการ และสัญลักษณ์วรรคตอน เป็นประเภทโทเค็นที่แตกต่างกัน
* Token validation: ขั้นตอนนี้จะตรวจสอบว่าโทเค็นแต่ละโทเค็นถูกต้องตามกฎของภาษาที่ใช้เขียน ตัวอย่างเช่น ตัวแบ่งประเภทโทเค็นอาจตรวจสอบว่า ชื่อตัวแปรเป็นตัวระบุที่ถูกต้อง หรือ ตัวดำเนินการมีไวยากรณ์ที่ถูกต้อง
* Output generation: ขั้นตอนสุดท้าย ตัวแบ่งประเภทโทเค็นจะสร้างผลลัพธ์ของขั้นตอนการวิเคราะห์ทางไวยากรณ์เบื้องต้น ซึ่งโดยทั่วไปเป็นรายการของโทเค็น รายการโทเค็นนี้สามารถส่งต่อไปยังขั้นตอนถัดไปของการแปลรหัสหรือการตีความ
```
int main()
{
  // 2 variables
  int a, b;
  a = 10;
 return 0;
}
```
Lexical Analysis จะแยกโค้ด C นี้เป็นโทเค็นดังต่อไปนี้:<br>

['int'  'main'  '('  ')'  '{'  'int'  'a' ','  'b'  ';'
 'a'  '='  '10'  ';' 'return'  '0'  ';'  '}]

## Syntax Analysis (การวิเคราะห์ไวยากรณ์)
<a name="Syntax-Analysis"></a>
Syntax Analysis หรือ Parsing จะทำหน้าที่ ตรวจสอบ ว่า โครงสร้างของโค้ด นั้น ถูกต้องตามกฎไวยากรณ์ของภาษาโปรแกรม หรือไม่ โดยใช้ parse tree หรือ abstract syntax tree (AST) แสดงโครงสร้างของโค้ด
ตัวอย่าง
```
x = 10 + 5

```
Lexical Analysis: แยก "x", "=", "10", "+", "5" ออกจากกัน<br>
Syntax Analysis: วิเคราะห์ว่า "x" เป็นตัวแปร "=" เป็นตัวดำเนินการ "10" และ "5" เป็นตัวถูกดำเนินการ และเรียงลำดับถูกต้อง<br>
Parse Tree:
```

    =
  /   \
 x     +
      / \
     10  5

```
AST:
```

=
|
x
|
+
|
10
5

```

## Semantic Analysis (การวิเคราะห์เชิงความหมาย)
<a name="Semantic-Analysis"></a>
ขั้นตอนที่ดำเนินต่อจาก Syntax Analysis หลังจากที่ตรวจสอบความถูกต้องตามไวยากรณ์ของภาษาโปรแกรมแล้ว เป้าหมายหลักของ Semantic Analysis คือการวิเคราะห์ความหมายเชิงตรรกะของโค้ด โดยมีหน้าที่สำคัญดังนี้:
* ตรวจสอบความถูกต้องและสอดคล้องของชนิดข้อมูล: เช่น ตรวจสอบว่าการบวกตัวเลขกับสตริงนั้นไม่ถูกต้อง, การเรียกใช้ฟังก์ชันกับอาร์กิวเมนต์ที่ไม่ตรงตามชนิดข้อมูลที่กำหนดไว้
* สร้างตารางสัญลักษณ์ (Symbol Table): เก็บข้อมูลเกี่ยวกับตัวแปร ฟังก์ชัน และชนิดข้อมูลต่างๆ ที่ใช้ในโค้ด
* วิเคราะห์การไหลของข้อมูล (Data Flow Analysis): วิเคราะห์ว่าข้อมูลไหลผ่านโค้ดอย่างไร ช่วยให้ Compiler
* เพิ่มประสิทธิภาพโค้ด (Code Optimization): วิเคราะห์โค้ดเพื่อหาโอกาสในการเพิ่มประสิทธิภาพ เช่น
```
public class Factorial {

    public static int factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("n must be non-negative!");
        } else if (n == 0) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }
    }

    public static void main(String[] args) {
        int n = 5;
        int result = factorial(n);
        System.out.println(n + "! = " + result);
    }
}
```
ในการวิเคราะห์ Semantic Analysis ของฟังก์ชัน Factorial ในตัวอย่างโค้ด Java นี้ Java Compiler จะมองดังนี้:<br>
*** ตัวอย่าง ***
* Type Checking Compiler จะตรวจสอบว่าชนิดข้อมูลของตัวแปร(variable)และนิพจน์(expression)สอดคล้องกันหรือไม่
    - n ถูกประกาศเป็น int และใช้กับการเปรียบเทียบ (< 0) และการคำนวณทางคณิตศาสตร์ (+, *)
    - ผลลัพธ์ของ factorial เป็น int
    - การบวกและการคูณใช้กับ int เท่านั้น
  Compiler พบว่าชนิดข้อมูลถูกต้องตามกฎภาษา Java
* Validity Checking:
        - Compiler จะตรวจสอบว่าการดำเนินการต่างๆถูกต้องตามตรรกะหรือไม่
        - ตรวจสอบเงื่อนไข n < 0 กรณีอินพุตเป็นค่าลบ
        - ตรวจสอบการส่งและรับค่าของฟังก์ชัน factorial
  Compiler พบว่าโค้ดถูกต้องตามตรรกะ

## Intermediate Code Generation (ICG)
<a name="ICG"></a>
